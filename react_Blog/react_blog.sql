-- phpMyAdmin SQL Dump
-- version 4.8.5
-- https://www.phpmyadmin.net/
--
-- Host: localhost:8889
-- Generation Time: Feb 19, 2022 at 09:17 AM
-- Server version: 5.7.25
-- PHP Version: 7.3.1

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `react_blog`
--

--
-- Dumping data for table `admin_user`
--

INSERT INTO `admin_user` (`id`, `userName`, `password`) VALUES
(1, 'jr', '123');

--
-- Dumping data for table `article`
--

INSERT INTO `article` (`id`, `type_id`, `title`, `article_content`, `introduce`, `addTime`, `view_count`) VALUES
(1, 1, 'react与redux基础使用', '#### 1、组件化开发\r\n\r\n组件：一块区域，包含了html、CSS和JS\r\n\r\n<img src=\'./images/1.png\' width=\"600\">\r\n\r\n组件开发优点：\r\n\r\n1）将应用拆分成不同组件，相互独立，易于维护\r\n\r\n2）组件复用，减少重复造轮子\r\n\r\n#### 2、搭建react开发环境\r\n\r\n##### 1）自定义webpack搭建\r\n\r\n安装的包\r\n\r\n```json\r\n\"devDependencies\": {\r\n    \"@babel/core\": \"^7.15.8\",\r\n    \"@babel/preset-env\": \"^7.15.8\",\r\n    \"@babel/preset-react\": \"^7.14.5\",\r\n    \"babel-loader\": \"^8.2.2\",\r\n    \"html-webpack-plugin\": \"^5.3.2\",\r\n    \"react\": \"^17.0.2\",\r\n    \"react-dom\": \"^17.0.2\",\r\n    \"webpack\": \"^5.58.1\",\r\n    \"webpack-cli\": \"^4.9.0\",\r\n    \"webpack-dev-server\": \"^3.11.2\"\r\n  }\r\n```\r\n\r\nwebpack基本配置\r\n\r\n```javascript\r\nconst path = require(\'path\');\r\nconst HTMLWebpackPlugin = require(\'html-webpack-plugin\');\r\n\r\nmodule.exports = {\r\n    mode:\'development\',\r\n    entry:\'./src/index.js\',\r\n    output:{\r\n        filename:\'main.js\',\r\n        path:path.resolve(__dirname,\'dist\')\r\n    },\r\n    devServer:{\r\n        port:3000,\r\n        hot:true\r\n    },\r\n    module:{\r\n        rules:[\r\n            {\r\n                test:/\\.js|jsx$/i,\r\n                exclude:/node_modules/,\r\n                use:{\r\n                    loader:\'babel-loader\',\r\n                    options:{\r\n                        presets:[\'@babel/preset-env\',\'@babel/preset-react\']\r\n                    }\r\n                }\r\n            }\r\n        ]\r\n    },\r\n    plugins:[\r\n        new HTMLWebpackPlugin({\r\n            template:\'./src/index.html\'\r\n        })\r\n    ]\r\n}\r\n```\r\n\r\n##### 2）脚手架初始化项目\r\n\r\n底部实现是封装了webpack\r\n\r\n```\r\n// 全局安装\r\nnpm i -g create-react-app\r\n// 创建项目\r\ncreate-react-app 02.react\r\n```\r\n\r\n#### 3、JSX语法\r\n\r\n##### 1）jsx是什么\r\n\r\n- JSX是JavaScript 的语法扩展，既不是字符串也不是 HTML（return后面的叫做jsx）\r\n- 它具有 JavaScript 的全部功能，同时可以被转为真实的DOM在界面上进行展示（react、react-dom）\r\n- JSX本身是一个表达式，运行之后会有一个结果，可以将其赋值给变量、 当成参数传递、函数返回值等\r\n\r\n##### 2）功能举例\r\n\r\n- 动态显示数据：{}\r\n\r\n- 调用方法：自定义 + 内置\r\n\r\n- 支持表达式，支持三元表达式\r\n\r\n- 模版字符串\r\n\r\n- 添加属性\r\n\r\n  字符串属性，直接用双引号包裹\r\n\r\n  动态属性\r\n\r\n- 添加子元素\r\n\r\n  jsx只允许有一个顶级元素 \r\n\r\n  单标签必须正确关闭\r\n\r\n```javascript\r\nconst name = \'react初体验\';\r\nconst flag = true;\r\nconst obj = {\r\n  name:\'react初体验\',\r\n  age:100\r\n};\r\nconst attri = \'动态属性\';\r\n\r\nfunction sayHello(){\r\n  return \'hello everyone\';\r\n}\r\n\r\nfunction App() {\r\n  return (\r\n    <div>\r\n      <div>React项目运行成功</div>\r\n      {/* 动态显示数据 */}\r\n      <p>{name}</p>\r\n      <p>name</p>\r\n      {/* 调用方法：自定义 + 内置 */}\r\n      <p>{sayHello()}</p>\r\n      <p>{console.log(\'hhhhh\')}</p>\r\n      <p>{Math.random()}</p>\r\n      {/* 支持表达式，支持三元表达式 */}\r\n      <p>{1+2+3}</p>\r\n      <p>{flag?\'登录的状态\':\'执行登录\'}</p>\r\n      {/* 模版字符串 */}\r\n      <p>{`hello,${name}`}</p>\r\n      {/* 对象不能直接打印，要转换为字符串 */}\r\n      <p>{JSON.stringify(obj)}</p>\r\n      {/* 添加动态属性 */}\r\n      <p title={attri}>添加动态属性</p>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n```\r\n\r\n#### 4、JSX事件操作\r\n\r\n##### 1）事件绑定\r\n\r\n驼峰命名直接添加={事件监听的名称}\r\n\r\n##### 2）事件监听传参\r\n\r\na.利用箭头函数内部调用事件监听的时候传递实参\r\n\r\nb.利用bind方法返回一个新的函数在事件发生时调用，此时也可传递参数\r\n\r\n##### 3）获取事件对象\r\n\r\na.默认情况下不需要接收参数且直接执行事件监听时，第一个参数默认就是ev\r\n\r\nb.利用箭头函数执行事件监听时，需要通过箭头函数将ev对象传递给事件监听函数\r\n\r\nc.利用bind方法时，如果有传参，那么最后一个参数默认就是ev\r\n\r\n#### 5、循环数据\r\n\r\nJSX中可以直接将数组的数据解构\r\n\r\n注意在循环中添加key，避免dom diff算法造成的问题\r\n\r\n```javascript\r\nconst persons = [\r\n  {\r\n    id:1,\r\n    name:\'jingran\',\r\n    age:18\r\n  },\r\n  {\r\n    id:2,\r\n    name:\'xiannv\',\r\n    age:28\r\n  }\r\n];\r\nfunction App() {\r\n  // newPersons相当于[<li>1</li>,<li>2</li>,<li>3</li>]\r\n  const newPersons = persons.map((item) => {\r\n    return (\r\n      <li key={item.id}>{item.name}--{item.age}</li>\r\n    );\r\n  });\r\n	return (<ul>{newPersons}</ul>);\r\n};\r\n```\r\n\r\n#### 6、添加内联样式\r\n\r\n- 设置样式时应该将键值对放置于{}\r\n- 内联样式默认无法支持伪类及媒询样式设置\r\n- 需利用radium\r\n\r\n#### 7、设置外联样式\r\n\r\n1）全局外联样式\r\n\r\n所有组件都可以直接使用\r\n\r\n2）组件级别外联样式\r\n\r\n只有某一个组件可以使用\r\n\r\n一般命名格式：组件名.module.css\r\n\r\n3）CSS-IN-JS的解决方案\r\n\r\n适用于较小的组件，只有一个JS文件即可，不需要配套的CSS文件\r\n\r\n```javascript\r\n// Test.js  Test组件\r\nimport style from \'./Test.module.css\';\r\nimport styled from \'styled-components\';\r\n\r\n// CSS-IN-JS解决方案，适用于比较小的组件\r\n// 自定义标签\r\nconst SectionDiv = styled.div.attrs({className:\'box\'})`\r\n    width:100px;\r\n    height:100px;\r\n    background-color:hotpink\r\n`\r\n\r\nfunction Test(){\r\n    return (\r\n        <div>\r\n            <div className={`box ${style.item}`}>Test组件</div>\r\n            <SectionDiv />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Test;\r\n```\r\n\r\n#### 8、组件创建方式\r\n\r\n##### 1）创建函数组件\r\n\r\n##### 2）创建类组件\r\n\r\n必须继承Component类，实现render方法\r\n\r\n组件名称首字母大写，用于区分组件和普通标记\r\n\r\n最外层要有根元素，为避免冗余嵌套的DOM，可使用占位符<Fragment></Fragment> / <></>\r\n\r\n#### 9、向组件传递数据\r\n\r\n- 方式一：在组件身上添加属性，然后传递数据\r\n- 方式二：将数据统一管理，然后利用...操作直接传递给相应组件\r\n\r\n根据组件的创建方式分两种情况看：\r\n\r\n- 函数组件\r\n\r\n  函数组件内参数部分定义一下，然后内部直接访问\r\n\r\n- 类组件\r\n\r\n  在类组件的内部存在一个props属性，外部传递的数据都放在这里保存\r\n\r\n#### 10、props默认值及类型校验\r\n\r\n函数组件:\r\n\r\n组件名称.defaultProps来设置一个对象\r\n\r\n```javascript\r\nTest.defaultProps = {\r\n    name:\'Test组件默认name\',\r\n    title:\'Test组件默认title\'\r\n};\r\nTest.propTypes = {\r\n    name:PropTypes.string,\r\n    title:PropTypes.string\r\n};\r\n```\r\n\r\n类组件：\r\n\r\n直接定义static defaultProps来设置\r\n\r\n```javascript\r\nclass About extends Component{\r\n    // 定义props默认值\r\n    static defaultProps = {\r\n        name:\'About组件默认name\',\r\n        title:\'About组件默认title\'\r\n    };\r\n\r\n    static propTypes = {\r\n        name:PropTypes.string,\r\n        title:PropTypes.string\r\n    };\r\n\r\n    render(){\r\n        // 父组件向该组件传递的参数\r\n        console.log(this);\r\n        console.log(this.props);\r\n        return (\r\n            <Fragment>\r\n                <p>{this.props.name}</p>\r\n                <p>{this.props.title}</p>\r\n          			{this.props.children}\r\n            </Fragment>\r\n        );\r\n    }\r\n}\r\n```\r\n\r\n#### 11、向组件传递JSX\r\n\r\n改写成双标签，里面包含的内容就是向组件传递的JSX\r\n\r\n在组件中用props.children接收\r\n\r\n#### 12、组件布局实例\r\n\r\n03.react\r\n\r\n方式一：将页面的每部分拆分成一个组件，在App根组件中进行组合。\r\n\r\n方式二：将页面的每部分拆分成一个组件，将固定部分（例如不变的头和尾）再次组合成新组件，变化部分放置占位符，通过向该新组件传递JSX组合成完整页面。\r\n\r\n#### 13、组件状态\r\n\r\n状态——数据\r\n\r\n组件状态：某一个组件里面保存的自己的数据\r\n\r\n```javascript\r\nimport React,{Component} from \'react\';\r\n\r\nclass StateBtn extends Component{\r\n    // 在类组件中存在一个state属性，它是一个对象，用来保存当前组件的数据\r\n    // 之后可以通过setState方法来修改数据的值，最后修改后的状态会自动更新到页面上\r\n    state = {\r\n        name:\'组件状态-组件自己的数据\',\r\n        value:Math.random()\r\n    }\r\n\r\n    // 易错：应写成箭头函数，里面的this代表上下文的this，即该StateBtn实例组件\r\n    changeValue = () => {\r\n        this.setState({\r\n            value:Math.random()\r\n        });\r\n    }\r\n\r\n    render(){\r\n        return (\r\n            <div>\r\n                <p>{this.state.name}</p>\r\n                <p>{this.state.value}</p>\r\n                <button onClick={this.changeValue}>改变数据</button>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default StateBtn;\r\n```\r\n\r\n#### 14、setState使用\r\n\r\n- setState是异步函数\r\n\r\n  直接在后面是获取不到最新值的（同步执行）\r\n\r\n  解决方法：\r\n\r\n  - 调用setState的时候可以传入回调函数，在回调函数里获取新值\r\n  - 使用async 与 await来解决异步执行的问题\r\n\r\n- 除了可以传入对象外，还可以传递函数（形参为state，返回值是对象），两者有不同点\r\n\r\n  ```javascript\r\n  changeCount = () => {   \r\n          // 传入函数（返回值是一个对象）时，多次操作会依次执行\r\n          this.setState((state) => ({\r\n              count:state.count+1\r\n          }));\r\n          this.setState((state) => ({\r\n              count:state.count+5\r\n          }));\r\n  \r\n          // 传入对象，多次操作会后面覆盖前面\r\n          // this.setState({\r\n          //     count:this.state.count + 5\r\n          // });\r\n  \r\n          // this.setState({\r\n          //     count:this.state.count + 1\r\n          // });\r\n  \r\n      }\r\n  ```\r\n\r\n  \r\n\r\n#### 15、组件中的this\r\n\r\n前面也提到过没有使用箭头函数时，this指向出现问题\r\n\r\n除了使用箭头函数外，也可以\r\n\r\n- ```javascript\r\n  <button onClick={()=>{this.changeValue()}}>改变数据</button>\r\n  ```\r\n\r\n- ```javascript\r\n  <button onClick={this.changeValue.bind(this)}>改变数据</button>\r\n  ```\r\n\r\n  \r\n\r\n#### 16、单向数据流动\r\n\r\n- 单向数据流动，自顶向下，从父组件传到子组件\r\n- 基于单向数据流动，要求将共享的数据定义在上层组件\r\n- 子组件通过调用父组件传递过来的方法可以更改数据\r\n- 当数据发生改变后，React会重新渲染组件树\r\n\r\n#### 17、受控表单值绑定与更新\r\n\r\n类似于Vue的表单控制（数据双向驱动）\r\n\r\n- 受控表单\r\n\r\n  表单元素的值全部交由react管理，值都放在state中，表单元素的值也需要从state中获取\r\n\r\n  通过setState方法修改（猜想底部实现基于setter、getter）\r\n\r\n- 做法\r\n\r\n  （1）将state中的状态与表单的value值进行绑定\r\n\r\n  ```javascript\r\n  changeForm = (ev) => {\r\n          // console.log(ev.target.name);\r\n          // console.log(ev.target.value);\r\n          const prop = ev.target.name;\r\n          this.setState({\r\n              [prop]:ev.target.value\r\n          });\r\n      }\r\n  \r\n  <input value={this.state.name} onChange={this.changeForm} name=\'name\'/>\r\n  ```\r\n\r\n  （2）  更新，ev.target.value 和 this.setState联用\r\n\r\n  （3）只是展示作用时，defaultValue和readOnly\r\n\r\n- 下拉框\r\n\r\n- 单选框\r\n\r\n- 复选框\r\n\r\n  前面数据绑定通过state和setState实现\r\n\r\n  复选框通过和模拟数据源绑定实现\r\n\r\n  最终提交时，state  + 复选框选中ID 一起提交\r\n\r\n```javascript\r\nimport React,{Component} from \'react\';\r\n\r\nclass ControlForm extends Component{\r\n    state={\r\n        subject:\'javascript\',\r\n        sex:\'女\'\r\n    }\r\n\r\n    // 模拟数据源\r\n    hobbies = [\r\n        {\r\n            id:1,\r\n            title:\'Vue\',\r\n            isChecked:true\r\n        },\r\n        {\r\n            id:2,\r\n            title:\'React\',\r\n            isChecked:false\r\n        },\r\n        {\r\n            id:3,\r\n            title:\'Anguler\',\r\n            isChecked:false\r\n        }\r\n    ]\r\n\r\n    changeCheckbox = (id,ev)=>{\r\n        // console.log(id);\r\n        // console.log(ev.target.checked);\r\n        this.hobbies[id-1].isChecked = ev.target.checked;\r\n    }\r\n\r\n    // 表单提交\r\n    submit = (ev) =>{\r\n        ev.preventDefault();\r\n        // 将当前结果:state状态 + 复选框的选择情况（ID）\r\n        let resCheckbox = this.hobbies.filter((item) => item.isChecked)\r\n        .map((item) => item.id);\r\n        console.log({...this.state,resCheckbox});\r\n    }\r\n\r\n    render(){\r\n        return (\r\n            <form onSubmit={this.submit}>\r\n                <p>下拉框</p>\r\n                <select value={this.state.subject} onChange={(ev)=>{this.setState({subject:ev.target.value})}}>\r\n                    <option value=\'python\'>python</option>\r\n                    <option value=\'c++\'>c++</option>\r\n                    <option value=\'javascript\'>javascript</option>\r\n                </select>\r\n                {/* 检验state中的subject值是否发生改变 */}\r\n                <button onClick={()=>{console.log(this.state.subject)}}>输出state.subject值</button>\r\n\r\n                <p>单选框</p>\r\n                <input type=\'radio\' name=\'sex\' value=\'男\' defaultChecked={this.state.sex === \'男\'} onChange={(ev)=>{this.setState({sex:ev.target.value})}}/><span>男</span>\r\n                <input type=\'radio\' name=\'sex\' value=\'女\' defaultChecked={this.state.sex === \'女\'} onChange={(ev)=>{this.setState({sex:ev.target.value})}}/><span>女</span>\r\n                <button onClick={()=>{console.log(this.state.sex)}}>输出state.sex值</button>\r\n\r\n                <p>复选框</p>\r\n                {\r\n                    this.hobbies.map((item)=>{\r\n                        return (\r\n                            <label key={item.id}>\r\n                                <input type=\'checkbox\' value={item.title} defaultChecked={item.isChecked} onChange={this.changeCheckbox.bind(this,item.id)}/>{item.title}\r\n                            </label>\r\n                        );\r\n                    })\r\n                }\r\n                <button onClick={()=>{console.log(this.hobbies)}}>输出复选框的选中状态</button>\r\n                <br />\r\n                <input type=\'submit\' />\r\n            \r\n            </form>\r\n        );\r\n    }\r\n}\r\n\r\nexport default ControlForm;\r\n```\r\n\r\n#### 18、非受控表单\r\n\r\n表单元素里的数据不受react管理，直接从DOM元素本身进行获取\r\n\r\n- 第一步：获取DOM元素\r\n- 第二步：获取具体的值\r\n\r\n```javascript\r\nimport React,{Component} from \'react\';\r\n\r\nclass UncontrolForm extends Component {\r\n\r\n    submit = (ev)=>{\r\n        ev.preventDefault();\r\n        // console.log(ev);\r\n        // console.log(this);\r\n        console.log(this.refs.username.value);\r\n    }\r\n\r\n    render(){\r\n        return (\r\n            <form onSubmit={this.submit}>\r\n                <input type=\'text\' ref=\'username\'/>\r\n                <input type=\'submit\' />\r\n            </form>\r\n        );\r\n    }\r\n}\r\n\r\nexport default UncontrolForm;\r\n```\r\n\r\n#### 19、简单管理系统练习\r\n\r\n#### 20、React组件生命周期\r\n\r\n生命周期函数（钩子）：预设的函数，在对应的时间点上被自动调用，不需要手动触发\r\n\r\n##### 1）挂载：组件被创建 -> 插入到DOM中 \r\n\r\n**生命周期方法：**\r\n\r\n- constructor  设置组件的初始配置\r\n\r\n- render  解析JSX，渲染DOM，在界面上展示\r\n\r\n- componentDidMount  组件挂载完成\r\n\r\n  发送网络请求\r\n\r\n  添加定时器\r\n\r\n  添加事件监听\r\n\r\n  DOM操作\r\n\r\n##### 2）更新：数据发生变化，组件需被重新渲染\r\n\r\n数据：外部传入的Props以及自身管理的状态\r\n\r\n**生命周期方法：**\r\n\r\n- shouldComponentUpdate(nextProps,nextState)  组件是否更新\r\n\r\n  默认返回的是true\r\n\r\n  如果此方法返回false，那么后续的方法就不会再执行\r\n\r\n- render  解析JSX，渲染DOM，在界面上展示\r\n\r\n- componentDidUpdate  组件更新完成后执行\r\n\r\n##### 3）卸载：将组件从DOM中删除\r\n\r\n**生命周期方法：**\r\n\r\ncomponentWillUnMount  将卸载组件相关的事件监听、定时器等清除\r\n\r\n#### 21、react发送Ajax请求\r\n\r\n 使用成熟的Ajax第三方库——axios\r\n\r\n```javascript\r\nimport React,{Component} from \'react\';\r\nimport axios from \'axios\';\r\n\r\nclass Compo2 extends Component{\r\n    constructor(){\r\n        super()\r\n        this.state = {\r\n            users:[]\r\n        }\r\n    }\r\n    render(){\r\n        return (\r\n            <div>\r\n                <p>axios数据请求</p>\r\n                {\r\n                    this.state.users.map((item) => {\r\n                        return (\r\n                            <div key={item.id}>\r\n                                <span>User&nbsp;&nbsp;{item.login}</span>&nbsp;&nbsp;\r\n                                <span>URL&nbsp;&nbsp;{item.avatar_url}</span>\r\n                            </div>\r\n                        )\r\n                    })\r\n                }\r\n            </div>\r\n        );\r\n    }\r\n    async componentDidMount(){\r\n        console.log(\'Compo2组件挂载完成了\');\r\n        //axios采用promise的形式处理返回数据\r\n        // axios.get(\'https://api.github.com/users\').then((res)=>{\r\n        //     console.log(res.data);\r\n        // })\r\n        const data = await axios.get(\'https://api.github.com/users\').then((res)=> res.data);\r\n        console.log(data);\r\n        this.setState({\r\n            users:data\r\n        })\r\n        \r\n    }\r\n}\r\n\r\nexport default Compo2;\r\n```\r\n\r\n#### 22、react请求转发\r\n\r\n<img src=\'./images/2.png\'>\r\n\r\n请求转发：\r\n\r\n服务端与服务端是不存在跨域问题的\r\n\r\n客户端应用发请求给同源的服务端，服务端将请求转发给API服务器端\r\n\r\n方法：\r\n\r\n- package.json配置proxy\r\n- http-proxy-middleware\r\n\r\n\r\n\r\n#### 23、mock数据 \r\n\r\n模拟数据行为\r\n\r\n#### 24、Redux工作流程\r\n\r\n单向数据流，顶层向底层组件传递数据和修改方法，造成组件之间通信困难\r\n\r\nRedux是React中进行数据管理的模块/包，它提供了一个叫store的统一数据存储的仓库\r\n\r\nstore就像一个数据管理的中间人，让组件之间无须再直接进行数据传递\r\n\r\n<img src=\'./images/3.png\'>\r\n\r\n- Store\r\n\r\n  对象类型：存储数据、更新视图\r\n\r\n  保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store\r\n\r\n  Redux 提供`createStore`这个函数，用来生成 Store。\r\n\r\n  ```javascript\r\n  import { createStore } from \'redux\';\r\n  const store = createStore(fn);\r\n  ```\r\n\r\n- Action Creators\r\n\r\n  对象类型： 存储数据的操作行为\r\n\r\n  State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。\r\n\r\n  ```javascript\r\n  const action = {\r\n    type: \'ADD_TODO\',\r\n    payload: \'Learn Redux\'\r\n  };\r\n  ```\r\n\r\n  上面代码中，Action 的名称是`ADD_TODO`，它携带的信息是字符串`Learn Redux`。\r\n\r\n  Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。\r\n\r\n- Reducer\r\n\r\n  函数类型：接收action的行为，处理数据，再把处理后的数据返回给store\r\n\r\n#### 25、创建store和reducer\r\n\r\n```javascript\r\n// Counter.reducer.js\r\nimport React,{Component} from \'react\';\r\n\r\nfunction reducer(){\r\n    return {\r\n        count:10\r\n    }\r\n}\r\n\r\nexport default reducer;\r\n```\r\n\r\n创建store\r\n\r\n```javascript\r\nimport {createStore} from \'redux\';\r\nimport {Provider} from \'react-redux\';\r\n\r\nconst store = createStore(CounterReducer);\r\n.\r\n.\r\n.\r\nrender(){\r\n    console.log(\'App组件的render执行了\');\r\n    return (\r\n      <Provider store={store}>\r\n        <div>\r\n          <p>这是App组件</p>\r\n          <span>{this.state.count}</span>\r\n          <button onClick={this.handler}>加1</button>\r\n          <hr />\r\n          <button onClick={()=>{this.setState({isShow:!this.state.isShow})}}>切换Compo1</button>\r\n          { this.state.isShow && <Compo1 />}\r\n          <hr />\r\n          <Compo2 />\r\n          <hr />\r\n          <Counter />\r\n      </div>\r\n      </Provider>\r\n    );\r\n```\r\n\r\n```javascript\r\n// Counter.js\r\nimport React from \'react\';\r\nimport {connect} from \'react-redux\';\r\n\r\nfunction Counter(props){\r\n    console.log(props)\r\n    return (\r\n        <div>\r\n            <button>-</button>\r\n            <span>{props.count}</span>\r\n            <button>+</button>\r\n        </div>\r\n    );\r\n}\r\n\r\nconst mapStateToProps = state => ({\r\n    count:state.count\r\n})\r\n\r\nexport default connect(mapStateToProps)(Counter)\r\n```\r\n\r\n#### 26、组件修改store数据\r\n\r\n```javascript\r\n// reducer的创建——接收action的行为，处理数据，再把处理后的数据返回给store\r\nconst initialState = {\r\n    count:10\r\n}\r\n\r\nfunction reducer(state=initialState,action){\r\n    // 没有state传来时返回默认initialState\r\n    // 有state传来时在原来的基础上进行修改\r\n    console.log(action);\r\n    switch(action.type){\r\n        case \'decrement\':\r\n            return{\r\n                count:state.count - 1\r\n            }\r\n        case \'increment\':\r\n            return{\r\n                count:state.count + 1\r\n            }\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nexport default reducer;\r\n```\r\n\r\n用户通过dispatch方法传action给reducer改变数据,reducer将改变后的数据返回给store\r\n\r\n```javascript\r\nimport React from \'react\';\r\nimport {connect} from \'react-redux\';\r\n\r\nfunction Counter(props){\r\n    console.log(props)\r\n    return (\r\n        <div>\r\n            <button onClick={()=>{props.dispatch({type:\'decrement\'})}}>-</button>\r\n            <span>{props.count}</span>\r\n            <button onClick={()=>{props.dispatch({type:\'increment\'})}}>+</button>\r\n        </div>\r\n    );\r\n}\r\n\r\nconst mapStateToProps = (state) => ({\r\n    count:state.count\r\n})\r\n\r\nexport default connect(mapStateToProps)(Counter)\r\n```\r\n\r\n#### 27、提取action代码为函数\r\n\r\n向connect函数传入第二个参数，对dispatch方法封装映射到props\r\n\r\n```javascript\r\nimport React from \'react\';\r\nimport {connect} from \'react-redux\';\r\n\r\nfunction Counter(props){\r\n    console.log(props)\r\n    return (\r\n        <div>\r\n            <button onClick={props.decrement}>-</button>\r\n            <span>{props.count}</span>\r\n            <button onClick={props.increment}>+</button>\r\n            <button onClick={()=>{props.increment_n(5)}}>+5</button>\r\n        </div>\r\n    );\r\n}\r\n\r\n// 从state中取数据映射到props上\r\nconst mapStateToProps = (state) => ({\r\n    count:state.count\r\n})\r\n// 对dispatch方法进行封装映射到props上\r\nconst mapDispatchToProps = (dispatch) => ({\r\n    // 函数组对象\r\n    increment(){\r\n        dispatch({type:\'increment\'})\r\n    },\r\n    decrement(){\r\n        dispatch({type:\'decrement\'})\r\n    },\r\n    increment_n(){\r\n        dispatch({type:\'increment_n\',payload:5})\r\n    }\r\n})\r\n\r\nexport default connect(mapStateToProps,mapDispatchToProps)(Counter)\r\n```\r\n\r\n#### 28、自动生成action触发函数\r\n\r\nbindActionCreators函数可以自动生成action触发函数\r\n\r\n```javascript\r\n// Counter.action.js\r\nexport const increment = ()=> ({type:\'increment\'})\r\nexport const decrement = ()=> ({type:\'decrement\'})\r\nexport const increment_n = (payload)=> ({type:\'increment_n\',payload})\r\n```\r\n\r\n```javascript\r\n// Counter.js\r\nimport React from \'react\';\r\nimport {connect} from \'react-redux\';\r\nimport {bindActionCreators} from \'redux\';\r\nimport * as counterActions from \'../store/actions/Counter.action\';\r\n\r\nfunction Counter(props){\r\n    console.log(props)\r\n    return (\r\n        <div>\r\n            <button onClick={props.decrement}>-</button>\r\n            <span>{props.count}</span>\r\n            <button onClick={props.increment}>+</button>\r\n            <button onClick={()=>{props.increment_n(6)}}>+6</button>\r\n        </div>\r\n    );\r\n}\r\n\r\n// 从state中取数据映射到props上\r\nconst mapStateToProps = (state) => ({\r\n    count:state.count\r\n})\r\n\r\n// 对dispatch方法进行封装映射到props上\r\n// const mapDispatchToProps = (dispatch) => ({\r\n//     // 函数组对象\r\n//     increment(){\r\n//         dispatch({type:\'increment\'})\r\n//     },\r\n//     decrement(){\r\n//         dispatch({type:\'decrement\'})\r\n//     },\r\n//     increment_n(payload){\r\n//         dispatch({type:\'increment_n\',payload})\r\n//     }\r\n// })\r\n\r\n// bindActionCreators函数可以自动生成action触发函数\r\n// counterActions 函数组对象，bindActionCreators将其分别与dispatch绑定后，返回的仍是函数组对象\r\nconst mapDispatchToProps = (dispatch)=>(bindActionCreators(counterActions,dispatch))\r\n\r\nexport default connect(mapStateToProps,mapDispatchToProps)(Counter)\r\n```\r\n\r\n#### 29、设置action类型常量\r\n\r\n将type中的字符串提取为常量，统一管理\r\n\r\n#### 30、reducer的拆分与合并\r\n\r\n为什么拆分：一个应用会有很多个组件，每个组件都有自己的数据，依据组件对reducer进行拆分\r\n\r\n利用combineReducers函数，将多个reducer合并到一起，返回一个所有数据组成的对象\r\n\r\n（一个应用只有一个store管理所有的数据，创建时只能传递一个reducer）\r\n\r\n```javascript\r\nimport {combineReducers} from \'redux\';\r\nimport CounterReducer from \'./Counter.reducer\';\r\nimport PersonReducer from \'./Person.reducer\';\r\n\r\nexport default combineReducers({\r\n    counter:CounterReducer,\r\n    person:PersonReducer\r\n})\r\n```\r\n\r\n#### 31、redux工作流程梳理\r\n\r\n核心：处理数据\r\n\r\n1. 创建store保存数据关联reducer\r\n2. 利用Provider将store向后传递\r\n3. 在具体的组件当中使用connect方法获取store里保存的数据，并通过组件的props进行访问\r\n4. 当拿到数据后就可以在界面上渲染了\r\n5. 修改数据时触发dispatch传递action给reducer，reducer处理数据后返回给store，store返回给组件，组件重新渲染\r\n\r\n优化：\r\n\r\n1. 合并处理数据的所有reducer交给store统一管理\r\n2. 让react自动的创建action执行的函数\r\n3. 将action类型使用的字符串定义为常量\r\n\r\n#### 32、redux中间件工作流程\r\n\r\n<img src=\'./images/4.png\'>\r\n\r\n异步操作交给中间件实现，将action拦截下来完成一些操作后再交给store\r\n\r\n中间件是个函数，核心是对数据进行操作\r\n\r\n<img src=\'./images/5.png\'>\r\n\r\n#### 33、redux-thunk异步解决方案\r\n\r\nthunk——中间件（工具包），里面完成异步行为（发送请求加载数据等）\r\n\r\n使用了thunk，action里面可以返回一个函数，而不一定是对象{type:,payload}\r\n\r\n#### 34、redux-saga异步解决方案\r\n\r\n#### 35、简化action与reducer\r\n\r\n', '内容包含react开发环境搭建、JSX语法、JSX事件操作、组件创建方式、组件数据传递、props默认值及类型校验等。', 1571394248, 0),
(2, 1, 'reactHooks基础学习与使用', 'hooks是react的新特性，react版本必须是16.8以上才行\r\n\r\nhooks的主要目的是不写class\r\n\r\n技术胖学习——https://jspang.com/detailed?id=50\r\n\r\n#### 1、useState\r\n\r\n**使函数组件拥有状态**\r\n\r\n在使用`useState`的时候只赋了初始值，并没有绑定任何的`key`,那React是怎么保证不同的useState找到它自己对应的state呢？\r\n\r\n**答案是：React是根据useState出现的顺序来确定的**\r\n\r\n- 不能存在条件判断语句中\r\n\r\n#### 2、useEffect\r\n\r\n**代替常用的生命周期函数**\r\n\r\n- 首次渲染（componentDidMount）和更新渲染（componentDidUpdate）\r\n\r\n- 它是异步执行的\r\n\r\n- 实现componentWillUnmount（组件将要被卸载时执行）\r\n\r\n  - 清除定时器、取消登录状态...\r\n\r\n  - 实现：返回一个函数进行解绑，更新渲染/卸载时会执行\r\n\r\n    ```javascript\r\n        // count状态更新时先执行解绑函数，在执行 console.log(`点击了第${count}次`);\r\n        // 第二个参数：数组中可以写入很多状态对应的变量，当状态值发生变化时，才进行解绑\r\n        useEffect(()=>{\r\n            console.log(`点击了第${count}次`);\r\n            return ()=>{\r\n                console.log(\"*************\");\r\n            }\r\n        },[count]);\r\n    ```\r\n\r\n    ```javascript\r\n        // 等价于componentWillUnmount，注意第二个参数[]，当组件将被销毁时才进行解绑\r\n        // 首次渲染时执行前面，最后卸载时执行 console.log(`卸载index`);\r\n        useEffect(()=>{\r\n            console.log(`index页面`);\r\n            return ()=>{\r\n                console.log(`卸载index`);\r\n            }\r\n        },[]);\r\n    ```\r\n\r\n#### 3、useContext\r\n\r\n**接收上下文变量，实现父子组件间跨层级传值**\r\n\r\n#### 4、useReducer\r\n\r\nreducer是一个函数，接收两个参数，一个是状态，一个是控制业务逻辑的判断参数\r\n\r\n**与useContext联合，实现类似redux的功能**\r\n\r\n- 基本用法\r\n\r\n```javascript\r\nimport React, { useReducer } from \'react\';\r\n\r\nfunction ReducerDemo(){\r\n    const [ count , dispatch ] =useReducer((state,action)=>{\r\n        switch(action){\r\n            case \'add\':\r\n                return state+1\r\n            case \'sub\':\r\n                return state-1\r\n            default:\r\n                return state\r\n        }\r\n    },0)\r\n    return (\r\n       <div>\r\n           <h2>现在的分数是{count}</h2>\r\n           <button onClick={()=>dispatch(\'add\')}>Increment</button>\r\n           <button onClick={()=>dispatch(\'sub\')}>Decrement</button>\r\n       </div>\r\n    )\r\n\r\n}\r\n\r\nexport default ReducerDemo\r\n```\r\n\r\n##### useReducer代替redux\r\n\r\n- `useContext`：可访问全局状态，避免一层层的传递状态。这符合`Redux`其中的一项规则，就是**状态全局化（共享**），并能统一管理\r\n\r\n- `useReducer`：通过action的传递，更新状态，主要是可以实现类似`Redux`中的`Reducer`部分\r\n\r\n- demo\r\n\r\n  ```javascript\r\n  // 状态共享组件 Color.js\r\n  import {createContext,useReducer} from \'react\';\r\n  export const Colorcontext = createContext();\r\n  export const UPDATE_COLOR = \'UPDATE_COLOR\';\r\n  \r\n  function colorReducer(state,action){\r\n      switch(action.type){\r\n          case \'UPDATE_COLOR\': return action.color;\r\n          default: return state;\r\n      }\r\n  }\r\n  \r\n  function Color(props){\r\n      const [color,dispatch] = useReducer(colorReducer,\'blue\');\r\n      \r\n      return (\r\n          <Colorcontext.Provider value={{color,dispatch}}>\r\n              {props.children}\r\n          </Colorcontext.Provider>\r\n      );\r\n  }\r\n  export default Color;\r\n  ```\r\n\r\n  ```javascript\r\n  // 最上层组件\r\n  import Color from \"./Color\";\r\n  \r\n  const { default: Buttons } = require(\"./Buttons\");\r\n  const { default: ShowArea } = require(\"./showArea\");\r\n  \r\n  function ReducerDemo(){\r\n      return (\r\n          <div>\r\n              <Color>\r\n                  <ShowArea />\r\n                  <Buttons />\r\n              </Color>\r\n          </div>\r\n      );\r\n  }\r\n  \r\n  export default ReducerDemo;\r\n  ```\r\n\r\n  ```javascript\r\n  // 子组件1\r\n  import {Colorcontext} from \'./Color\';\r\n  import {useContext} from \'react\';\r\n  \r\n  function ShowArea(){\r\n      let {color} = useContext(Colorcontext); // useContext返回的是传入的对象\r\n      return (\r\n          <div style={{color:color}}>\r\n              字体颜色为{color}\r\n          </div>\r\n      );\r\n  }\r\n  export default ShowArea;\r\n  \r\n  // 子组件2\r\n  import {useContext} from \'react\';\r\n  import {Colorcontext,UPDATE_COLOR} from \'./Color\';\r\n  \r\n  function Buttons(){\r\n      let {dispatch} = useContext(Colorcontext);\r\n      return (\r\n          <div>\r\n              <button onClick={()=>{dispatch({type:UPDATE_COLOR,color:\'red\'})}}>红色</button>\r\n              <button onClick={()=>{dispatch({type:UPDATE_COLOR,color:\'blue\'})}}>蓝色</button>\r\n          </div>\r\n      );\r\n  }\r\n  export default Buttons;\r\n  ```\r\n\r\n\r\n\r\n#### 5、useMemo\r\n\r\n**用来解决使用React hooks产生的无用渲染的性能问题**\r\n\r\n使用function的形式来声明组件，失去了`shouldCompnentUpdate`（在组件更新之前）这个生命周期，也就是说我们没有办法通过组件更新前条件来决定组件是否更新（比如父组件状态更新，子组件内部全部重新调用执行）。而且在函数组件中，也不再区分`mount`和`update`两个状态，这意味着**函数组件的每一次调用都会执行内部的所有逻辑**，就带来了非常大的性能损耗。`useMemo`和`useCallback`都是解决上述性能问题的。\r\n\r\n```javascript\r\n// 父组件\r\nimport React , {useState,useMemo} from \'react\';\r\nfunction Example7(){\r\n    const [xiaohong , setXiaohong] = useState(\'小红待客状态\')\r\n    const [zhiling , setZhiling] = useState(\'志玲待客状态\')\r\n    return (\r\n        <>\r\n            <button onClick={()=>{setXiaohong(new Date().getTime())}}>小红</button>\r\n            <button onClick={()=>{setZhiling(new Date().getTime()+\',志玲向我们走来了\')}}>志玲</button>\r\n            <ChildComponent name={xiaohong}>{zhiling}</ChildComponent>\r\n        </>\r\n    )\r\n}\r\n// 子组件\r\nfunction ChildComponent({name,children}){\r\n    function changeXiaohong(name){\r\n        console.log(\'她来了，她来了。小红向我们走来了\')\r\n        return name+\',小红向我们走来了\'\r\n    }\r\n    // 只有name发生改变时changeXiaohong函数才执行\r\n    const actionXiaohong = useMemo(()=>changeXiaohong(name),[name]) \r\n    return (\r\n        <>\r\n            <div>{actionXiaohong}</div>\r\n            <div>{children}</div>\r\n        </>\r\n    )\r\n}\r\n```\r\n\r\n- useMemo缓存状态（属性）\r\n- useCallback缓存方法\r\n\r\n\r\n\r\n#### 6、useRef\r\n\r\n- **获取DOM元素**\r\n- **保存普通变量**\r\n\r\n#### 7、自定义hooks函数\r\n\r\n要用use开头，这样才能区分出什么是组件，什么是自定义hooks函数\r\n\r\n自定义Hooks函数偏向于功能，而组件偏向于界面和业务逻辑\r\n\r\n- 自定义hooks函数获取窗口大小\r\n\r\n  ```javascript\r\n  // 自定义hooks函数\r\n  import {useState,useCallback,useEffect} from \'react\';\r\n  \r\n  function useWinSize(){\r\n      // 设置变量\r\n      const [size,setSize] = useState({\r\n          width:document.documentElement.clientWidth,\r\n          height:document.documentElement.clientHeight\r\n      });\r\n  \r\n      // 定义监听窗口变化触发函数，useCallback缓存方法(useMemo是为了缓存变量)\r\n      const onResize = useCallback(() => {\r\n              setSize({\r\n                  width:document.documentElement.clientWidth,\r\n                  height:document.documentElement.clientHeight\r\n              });\r\n          },[])\r\n  \r\n      // 开启监听窗口变化。第一次进入方法时用useEffect来注册resize监听事件，在方法移除时，使用return返回的解绑函数移除监听\r\n      useEffect(()=>{\r\n          window.addEventListener(\'resize\',onResize);\r\n          return ()=>{\r\n              window.removeEventListener(\'resize\',onResize);\r\n          };\r\n      },[]);\r\n  \r\n      return size;\r\n  }\r\n  \r\n  // 使用自定义的hooks函数\r\n  function Example3(){\r\n      const size = useWinSize();\r\n      return (\r\n          <div>窗口大小为{size.width}*{size.height}</div>\r\n      );\r\n  }\r\n  \r\n  export default Example3;\r\n  ```\r\n\r\n  \r\n\r\n', 'hooks是react的新特性，react版本必须是16.8以上才行。hooks的主要目的是不写class，使函数组件拥有状态。\r\n', 1571394253, 0),
(3, 1, 'reactRouter基础学习', '#### 1、react router 动态传值\r\n\r\n- 应用：列表-详情页\r\n\r\n- 业务逻辑\r\n\r\n  - （1）设置规则\r\n  - （2）传递值\r\n  - （3）接收值\r\n  - （4）显示内容\r\n\r\n  ```javascript\r\n  import {BrowserRouter as Router,Routes,Route,Link,useParams} from \'react-router-dom\';\r\n  import {useState} from \'react\';\r\n  \r\n  function Index(){\r\n      return (\r\n          <div>Index</div>\r\n      );\r\n  }\r\n  \r\n  function ArticlePage(){\r\n      const params = useParams();\r\n      return (\r\n          <div>\r\n              <h5>文章详情页</h5>\r\n              <h5>article ID：{params.id}</h5>\r\n          </div>\r\n      );\r\n  }\r\n  \r\n  function List(){\r\n      const [articleLists,setArticleLists] = useState([\r\n          {id:123,title:\'一叶扁舟\'},\r\n          {id:124,title:\'满城春色宫墙柳\'},\r\n          {id:125,title:\'黄滕酒\'},\r\n          {id:126,title:\'红酥手\'}\r\n      ]);\r\n  \r\n      return (\r\n         <div>\r\n              <ul>\r\n              {\r\n                  articleLists.map(item => {\r\n                      return (\r\n                          <li key={item.id}><Link to={`/list/article/${item.id}`}>{item.title}</Link></li>\r\n                      );\r\n                  })\r\n              }\r\n              </ul>\r\n          </div>\r\n      );\r\n  }\r\n  ```\r\n\r\n  ```javascript\r\n  function Example4(){\r\n      return (\r\n          <div>\r\n              <Router>\r\n                  <ul>\r\n                      <li><Link to=\"/\">首页</Link></li>\r\n                      <li><Link to=\"/list\">文章列表</Link></li>\r\n                  </ul>\r\n                  <Routes>\r\n                      <Route path=\"/\" element={<Index/>}></Route>\r\n                      <Route path=\"/list\" element={<List/>}></Route>\r\n                      <Route path=\'/list/article/:id\' element={<ArticlePage/>}></Route>\r\n                  </Routes>\r\n              </Router>\r\n          </div>\r\n      );\r\n  }\r\n  \r\n  export default Example4;\r\n  ```\r\n\r\n  \r\n\r\n#### 2、重定向redirect\r\n\r\n- 标签式重定向:就是利用`<Redirect>`标签来进行重定向，业务逻辑不复杂时建议使用这种\r\n- 编程式重定向:这种是利用编程的方式，一般用于业务逻辑当中，比如登录成功挑战到会员中心页面\r\n\r\n**重定向和跳转有一个重要的区别，就是跳转是可以用浏览器的回退按钮返回上一级的，而重定向是不可以的。**\r\n\r\n```javascript\r\nfunction Index(props){\r\n    // 第二种\r\n    window.location.href = \'/home\';\r\n    return (\r\n        <div>\r\n            // 第一种\r\n            {/* <Navigate to=\'/home\'/> */}\r\n            Index\r\n        </div>\r\n    );\r\n}\r\n```\r\n\r\n#### 3、嵌套路由\r\n\r\nReact router V6版本使用： https://zhuanlan.zhihu.com/p/191419879\r\n\r\n```javascript\r\n// AppRouter.js\r\nimport {BrowserRouter as Router,Routes,Route,Link} from \'react-router-dom\';\r\nimport Index from \'./Pages/Index\';\r\nimport \'../index.css\';\r\nimport Video from \'./Pages/Video\';\r\nimport Workplace from \'./Pages/Workplace\';\r\n\r\nimport VuePage from \'./Pages/video/VuePage\';\r\nimport ReactPage from \'./Pages/video/ReactPage\';\r\nimport FlutterPage from \'./Pages/video/FlutterPage\';\r\n\r\nimport Money from \'./Pages/workplace/Money\';\r\nimport Getup from \'./Pages/workplace/Getup\';\r\n\r\nfunction AppRouter(){\r\n    return (\r\n        <div className=\'mainDiv\'>\r\n            <Router>\r\n                <div className=\'leftNav\'>\r\n                    <h3>一级导航</h3>\r\n                    <ul>\r\n                        <li><Link to=\'/\'>博客首页</Link></li>\r\n                        <li><Link to=\'/video\'>视频教程</Link></li>\r\n                        <li><Link to=\'/workplace\'>职场技能</Link></li>\r\n                    </ul>\r\n                </div>\r\n                <div className=\'rightMain\'>\r\n                    <Routes>\r\n                        <Route path=\'/\' element={<Index/>}></Route>\r\n                        <Route path=\'/video\' element={<Video/>}>\r\n                            <Route path=\'/video/vue\' element={<VuePage/>}></Route>\r\n                            <Route path=\'/video/react\' element={<ReactPage/>}></Route>\r\n                            <Route path=\'/video/flutter\' element={<FlutterPage/>}></Route>\r\n                        </Route>\r\n                        <Route path=\'/workplace\' element={<Workplace/>}>\r\n                            <Route path=\'/workplace/money\' element={<Money/>}></Route>\r\n                            <Route path=\'/workplace/getup\' element={<Getup/>}></Route>\r\n                        </Route>\r\n\r\n                    </Routes>\r\n                </div>\r\n            </Router>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default AppRouter;\r\n```\r\n\r\n```javascript\r\n// Video.js\r\nimport {Link, Outlet} from \'react-router-dom\';\r\n\r\n\r\nfunction Video(){\r\n    return (\r\n        <div>\r\n            <div className=\'topNav\'>\r\n                <ul>\r\n                    <li><Link to=\'/video/vue\'>Vue教程</Link></li>\r\n                    <li><Link to=\'/video/react\'>React教程</Link></li>\r\n                    <li><Link to=\'/video/flutter\'>fluter教程</Link></li>\r\n                </ul>\r\n            </div>\r\n            <div className=\'videoContent\'>\r\n                <h4>视频教程</h4>\r\n                <Outlet/>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Video;\r\n```\r\n\r\n', '内容包含路由动态传值、重定向redirect、嵌套路由等等。', 1571414400, 0);

--
-- Dumping data for table `blog_content`
--

INSERT INTO `blog_content` (`title`, `type`, `introduce`, `content`) VALUES
('测试文章', '视频教程', '测试文章简介。。。。', '如果能在控制台打印出结果和页面中显示结果，说明数据库已经连接成功了。这节课主要讲解了egg.js中mysql数据的连接方式，下节课我们简单的介绍一下数据库的增删改查操作');

--
-- Dumping data for table `type`
--

INSERT INTO `type` (`id`, `typeName`, `orderNum`) VALUES
(1, 'React', 1),
(2, 'JavaScript', 2),
(3, '前端基础', 3);

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
